#!/usr/bin/env python3
"""
Telegram Bot Handlers for Patch Management

Commands:
  /patch                  - Show patch system status and help
  /patch_status           - Show current version and recent patches
  /patch_list             - List available patches to apply
  /patch_apply <name>     - Apply a specific patch
  /patch_rollback [tag]   - Rollback to a previous state
"""

import os
import subprocess
import json
import logging
from pathlib import Path
from datetime import datetime
from telegram import Update
from telegram.ext import ContextTypes

logger = logging.getLogger(__name__)

# Configuration
MYTHOS_ROOT = Path("/opt/mythos")
PATCH_DIR = MYTHOS_ROOT / "patches"
PATCH_SCRIPTS = PATCH_DIR / "scripts"
PATCH_LOGS = PATCH_DIR / "logs"

# Authorized users (from .env: TELEGRAM_ID_KA, TELEGRAM_ID_SERAPHE)
AUTHORIZED_IDS = set()

def _load_authorized_ids():
    """Load authorized Telegram IDs from environment"""
    global AUTHORIZED_IDS
    for key in ['TELEGRAM_ID_KA', 'TELEGRAM_ID_SERAPHE']:
        val = os.getenv(key)
        if val:
            try:
                AUTHORIZED_IDS.add(int(val))
            except ValueError:
                pass
    logger.info(f"Authorized patch users: {AUTHORIZED_IDS}")

_load_authorized_ids()

def _is_authorized(user_id: int) -> bool:
    """Check if user is authorized for patch operations"""
    return user_id in AUTHORIZED_IDS

def _run_git(*args) -> tuple[bool, str]:
    """Run a git command and return (success, output)"""
    try:
        result = subprocess.run(
            ["git"] + list(args),
            cwd=MYTHOS_ROOT,
            capture_output=True,
            text=True,
            timeout=30
        )
        return result.returncode == 0, result.stdout + result.stderr
    except Exception as e:
        return False, str(e)

def _get_current_version() -> str:
    """Get current git version tag"""
    success, output = _run_git("tag", "-l", "v*", "--sort=-v:refname")
    if success and output.strip():
        return output.strip().split('\n')[0]
    return "v0.0.0"

def _get_recent_tags(limit: int = 5) -> list[dict]:
    """Get recent tags with dates"""
    tags = []
    success, output = _run_git("tag", "-l", "--sort=-v:refname")
    if success:
        for tag in output.strip().split('\n')[:limit]:
            if tag:
                _, date_out = _run_git("log", "-1", "--format=%ci", tag)
                tags.append({
                    "tag": tag,
                    "date": date_out.strip()[:19] if date_out else "unknown"
                })
    return tags

def _get_pending_patches() -> list[str]:
    """Get list of patch directories that haven't been applied"""
    patches = []
    if PATCH_DIR.exists():
        for d in sorted(PATCH_DIR.iterdir()):
            if d.is_dir() and d.name.startswith("patch_"):
                # Check if it has an install.sh
                has_install = (d / "install.sh").exists()
                patches.append(f"{d.name}" + (" ‚úì" if has_install else ""))
    return patches

def _get_recent_logs(limit: int = 5) -> list[dict]:
    """Get recent patch application logs"""
    logs = []
    if PATCH_LOGS.exists():
        log_files = sorted(PATCH_LOGS.glob("*.json"), reverse=True)[:limit]
        for f in log_files:
            try:
                with open(f) as fp:
                    logs.append(json.load(fp))
            except Exception:
                pass
    return logs


# ============================================================
# Command Handlers
# ============================================================

async def patch_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /patch - Show patch system overview and help
    """
    user_id = update.effective_user.id
    
    if not _is_authorized(user_id):
        await update.message.reply_text("‚ùå Not authorized for patch operations.")
        return
    
    version = _get_current_version()
    
    help_text = f"""
üîß **Mythos Patch System**

**Current Version:** `{version}`

**Commands:**
‚Ä¢ `/patch_status` - Version info & recent activity
‚Ä¢ `/patch_list` - Available patches to apply
‚Ä¢ `/patch_apply <name>` - Apply a specific patch
‚Ä¢ `/patch_rollback` - Show rollback options
‚Ä¢ `/patch_rollback <tag>` - Rollback to specific tag

**Auto-Processing:**
Patch zips dropped in `~/Downloads` are automatically:
1. Extracted to `/opt/mythos/patches/`
2. Git-tagged before & after
3. Pushed to GitHub

**Naming Convention:**
`patch_NNNN_description.zip`
"""
    
    await update.message.reply_text(help_text, parse_mode=None)


async def patch_status_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /patch_status - Show current version and recent patches
    """
    user_id = update.effective_user.id
    
    if not _is_authorized(user_id):
        await update.message.reply_text("‚ùå Not authorized for patch operations.")
        return
    
    version = _get_current_version()
    tags = _get_recent_tags(5)
    logs = _get_recent_logs(3)
    
    # Check git remote
    has_remote, remote_url = _run_git("remote", "get-url", "origin")
    
    msg = f"üìä **Patch Status**\n\n"
    msg += f"**Current Version:** `{version}`\n"
    msg += f"**GitHub:** {'‚úì Connected' if has_remote else '‚úó Not configured'}\n\n"
    
    msg += "**Recent Tags:**\n"
    for t in tags[:5]:
        msg += f"‚Ä¢ `{t['tag']}` ({t['date'][:10]})\n"
    
    if logs:
        msg += "\n**Recent Activity:**\n"
        for log in logs[:3]:
            status = "‚úì" if log.get('status') == 'success' else "‚úó"
            patch_name = log.get('patch', log.get('target_tag', 'unknown'))
            msg += f"‚Ä¢ {status} {patch_name}\n"
    
    await update.message.reply_text(msg, parse_mode=None)


async def patch_list_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /patch_list - List available patches
    """
    user_id = update.effective_user.id
    
    if not _is_authorized(user_id):
        await update.message.reply_text("‚ùå Not authorized for patch operations.")
        return
    
    patches = _get_pending_patches()
    
    if not patches:
        await update.message.reply_text("üì¶ No patches in `/opt/mythos/patches/`", parse_mode=None)
        return
    
    msg = "üì¶ **Available Patches:**\n\n"
    for p in patches:
        msg += f"‚Ä¢ `{p}`\n"
    
    msg += "\nUse `/patch_apply <name>` to apply."
    
    await update.message.reply_text(msg, parse_mode=None)


async def patch_apply_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /patch_apply <patch_name> - Apply a specific patch
    """
    user_id = update.effective_user.id
    
    if not _is_authorized(user_id):
        await update.message.reply_text("‚ùå Not authorized for patch operations.")
        return
    
    if not context.args:
        await update.message.reply_text(
            "Usage: `/patch_apply <patch_name>`\n\n"
            "Use `/patch_list` to see available patches.",
            parse_mode=None
        )
        return
    
    patch_name = context.args[0]
    patch_path = PATCH_DIR / patch_name
    
    if not patch_path.exists():
        await update.message.reply_text(f"‚ùå Patch not found: `{patch_name}`", parse_mode=None)
        return
    
    await update.message.reply_text(f"‚è≥ Applying patch: `{patch_name}`...", parse_mode=None)
    
    try:
        script = PATCH_SCRIPTS / "patch_apply.sh"
        if not script.exists():
            await update.message.reply_text("‚ùå patch_apply.sh not found!")
            return
        
        result = subprocess.run(
            [str(script), str(patch_path)],
            capture_output=True,
            text=True,
            timeout=300
        )
        
        if result.returncode == 0:
            new_version = _get_current_version()
            await update.message.reply_text(
                f"‚úÖ Patch applied successfully!\n\n"
                f"**New version:** `{new_version}`",
                parse_mode=None
            )
        else:
            error_msg = result.stderr[-500:] if result.stderr else "Unknown error"
            await update.message.reply_text(
                f"‚ùå Patch failed!\n\n```\n{error_msg}\n```",
                parse_mode=None
            )
    
    except subprocess.TimeoutExpired:
        await update.message.reply_text("‚ùå Patch timed out (5 min limit)")
    except Exception as e:
        await update.message.reply_text(f"‚ùå Error: {e}")


async def patch_rollback_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /patch_rollback [tag] - Show rollback options or rollback to specific tag
    """
    user_id = update.effective_user.id
    
    if not _is_authorized(user_id):
        await update.message.reply_text("‚ùå Not authorized for patch operations.")
        return
    
    # No arguments - show available rollback points
    if not context.args:
        tags = _get_recent_tags(10)
        
        pre_tags = [t for t in tags if t['tag'].startswith('pre-')]
        version_tags = [t for t in tags if t['tag'].startswith('v')]
        
        msg = "üîÑ **Rollback Options**\n\n"
        
        if pre_tags:
            msg += "**Pre-patch snapshots:**\n"
            for t in pre_tags[:5]:
                msg += f"‚Ä¢ `{t['tag']}`\n"
        
        if version_tags:
            msg += "\n**Version tags:**\n"
            for t in version_tags[:5]:
                msg += f"‚Ä¢ `{t['tag']}` ({t['date'][:10]})\n"
        
        msg += "\nUse `/patch_rollback <tag>` to rollback."
        
        await update.message.reply_text(msg, parse_mode=None)
        return
    
    # Rollback to specific tag
    target_tag = context.args[0]
    
    # Verify tag exists
    success, _ = _run_git("rev-parse", target_tag)
    if not success:
        await update.message.reply_text(f"‚ùå Tag not found: `{target_tag}`", parse_mode=None)
        return
    
    await update.message.reply_text(
        f"‚ö†Ô∏è **Confirm Rollback**\n\n"
        f"Rolling back to: `{target_tag}`\n\n"
        f"Reply with `/patch_rollback_confirm {target_tag}` to proceed.",
        parse_mode=None
    )


async def patch_rollback_confirm_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /patch_rollback_confirm <tag> - Actually perform the rollback
    """
    user_id = update.effective_user.id
    
    if not _is_authorized(user_id):
        await update.message.reply_text("‚ùå Not authorized for patch operations.")
        return
    
    if not context.args:
        await update.message.reply_text("Usage: `/patch_rollback_confirm <tag>`", parse_mode=None)
        return
    
    target_tag = context.args[0]
    
    await update.message.reply_text(f"‚è≥ Rolling back to `{target_tag}`...", parse_mode=None)
    
    try:
        # Use the rollback script with auto-confirm via stdin
        script = PATCH_SCRIPTS / "patch_rollback.sh"
        if not script.exists():
            await update.message.reply_text("‚ùå patch_rollback.sh not found!")
            return
        
        # We need to bypass the confirmation prompt
        # Instead, run git commands directly
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        pre_rollback_tag = f"pre-rollback-{timestamp}"
        
        # Save current state
        _run_git("add", "-A")
        _run_git("commit", "-m", f"Auto-commit before rollback to {target_tag}")
        _run_git("tag", "-a", pre_rollback_tag, "-m", f"State before rollback to {target_tag}")
        
        # Checkout target state
        success, output = _run_git("checkout", target_tag, "--", ".")
        if not success:
            await update.message.reply_text(f"‚ùå Rollback failed:\n```\n{output}\n```", parse_mode=None)
            return
        
        # Commit rollback
        _run_git("add", "-A")
        _run_git("commit", "-m", f"Rollback to {target_tag}")
        
        # Push
        _run_git("push", "origin", "main", "--tags")
        
        # Restart service
        subprocess.run(["sudo", "systemctl", "restart", "mythos-patch-monitor"], capture_output=True)
        
        await update.message.reply_text(
            f"‚úÖ Rollback complete!\n\n"
            f"**Rolled back to:** `{target_tag}`\n"
            f"**Previous state saved as:** `{pre_rollback_tag}`",
            parse_mode=None
        )
    
    except Exception as e:
        await update.message.reply_text(f"‚ùå Rollback error: {e}")


# Export all handlers
__all__ = [
    'patch_command',
    'patch_status_command', 
    'patch_list_command',
    'patch_apply_command',
    'patch_rollback_command',
    'patch_rollback_confirm_command'
]
